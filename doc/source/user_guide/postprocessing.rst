.. _postprocessing:

Postprocessing
==============

Once a case has been setup correctly so it can be run without errors, you may want 
to modify the postprocessing to of the simulation output. By default, NekRS will
output a basic set of data according to frequency set in the ``checkpointInterval`` of
the :ref:`parameter_file` which can subsequently be viewed through a visualization
tool such as Paraview or Visit. However, additional data or derived values can
be extracted by setting up User Defined outputs using the ``UDF_ExecuteStep``
function of the ``.udf`` file.

.. _checkpointing_visualisation:

Checkpointing & Visualization
-----------------------------

Standard NekRS field data output files have the form ``<case>0.f<n>``, where
``<case>`` is the case name and ``<n>`` is a five-digit number indicating the
number of the output file (each output file represents a single time step that
is output according to the settings for ``checkpointControl`` and
``checkpointInterval`` in the ``.par`` file). These output files are in
`Nek5000 format <https://nek5000.github.io/NekDoc/problem_setup/case_files.html#restart-output-files-f>`__
that has a line of ascii header followed by binary data. It requires a metadata
file ``<case>.nek5000`` to be viewable in Paraview or VisIt. This should be
automatically generated by NekRS, but can also be manually created using the
``nrsvis`` script.

.. _custom_checkpoint:

Adding Custom Fields
""""""""""""""""""""

For each COMMON field, one can use ``checkpointing = true`` to toggle on (or off)
and decide whether dumping a specific field into checkpoint files. Combined
with ``solver = none``, the extra fields can be stored into auxiliary scalar fields.
This is equivalent to simply attach the pointer to a field name.

FIXME: size of scalars? std::vector? occupied scalar01? 
For instance, the following line will add the density to the slot of ``scalar01``.

.. code-block:: cpp
    
    nrs->addUserCheckpointField("scalar01", std::vector<deviceMemory<dfloat>>{nrs->o_rho});

Adding Custom Output File
"""""""""""""""""""""""""

A more flexible approach is to dump all desired fields into a separate file. 

FIXME: mesh?, particles (adios2)? name for nek engine?

``iofldFactory`` APIs:


The variable name must match with default field names. 
Otherwise, ?? restart fail?, iofldNek fails?

.. code-block:: cpp

    // UDF global variable
    std::unique_ptr<iofld> iofld;

    // UDF_Setup
    iofld = iofldFactory::create();
    iofld->open(mesh, iofld::mode::write, "properties");
    iofld->writeAttribute("uniform", "true");
    iofld->writeAttribute("polynomialOrder", std::to_string(mesh->N + 2));

    iofld->addVariable("scalar00", std::vector<deviceMemory<dfloat>>{nrs->o_rho});
    // FIXME: add vector example
    iofld->addVariable("velocityscalar00", std::vector<deviceMemory<dfloat>>{nrs->o_NLT});

    // UDF_ExecuteStep
    iofld->addVariable("time", time);
    iofld->process();
    if (nrs->lastStep) iofld->close();





- ``polynomialOrder``: Can be a different polynomial order. 
- ``uniform``: Interpolation data from GLL points to uniform grid.
- Element filter: Only dump the elements in the list. For example, the below
  code snippet coped from ``turbPipe`` filters out the elements which has
  ``zmax`` larger than ``zRecycLayer``.

  .. code-block:: cpp
    :emphasize-lines: 11

    auto elementFilter = [&]() 
    { 
      std::vector<int> elementFilter;
      for(int e = 0; e < mesh->Nelements; e++) {
         auto zmaxLocal = std::numeric_limits<dfloat>::lowest();
         for(int i = 0; i < mesh->Np; i++) zmaxLocal = std::max(z[i + e * mesh->Np], zmaxLocal);
         if (zmaxLocal > zRecycLayer) elementFilter.push_back(e);
      }
      return elementFilter;
    }();
    iofld->writeElementFilter(elementFilter); // FIXME copied or referenced?


ParaView & VisIt
""""""""""""""""

FIXME: add how nek translated into vtk
nek5000 reader
5.12, new nek5000 reader

.. _compute_derived:

Compute Derived Quantity
------------------------

Additional control of the simulation to compute additional/derived quantities 
or output custom fields can be achieved by utilising the ``UDF_ExecuteStep`` 
function of the ``.udf`` file. Here we demonstrate how this can be used to 
compute a derived quantity and output custom fields.

Qcriterion in turbPipe example
opSEM, nusselt, 

``checkpointStep``

Built-in Operators
""""""""""""""""""

linAlg
surface integral
volume integral
opSEM

qcriterion
nusselt
aero force


.. _turbulence_stats:

Runtime Averaging
"""""""""""""""""

tavg plugin

Planar Averaging

nusselt of space
averaged


Sample Points & Particle Tracking
"""""""""""""""""""""""""""""""""

plot over lines
particle tracking
hpts()

Legacy Support (userchk)
""""""""""""""""""""""""


Guideline for Custom Output
---------------------------

stdout, 
grep -v >>>
flush cache to logfile
MPIIO command
Particles 

FIXME: remove this? leave a simple example under particles




Adios2 Format
-------------

``checkpointEngine = adios``

reading from uniform?
particles?

ParaView Reader
VisIt (issue)
bpls commands, links to adios2 doc

On HPC, one might want to use 
``export ADIOS2_INSTALL_DIR=<path-to-adios2>``
ENABLE_ADIOS FIXME: move to installation

$NEKRS_HOME/bin/bpls turbPipe.bp
bpls -h
bpls -l 
bpls time -d

In-Situ Visualization
---------------------

link to Ascent
installation, hpc, docker,
gpu, vtkh
add paper?

