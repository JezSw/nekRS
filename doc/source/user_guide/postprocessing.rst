.. _postprocessing:

Postprocessing
==============

Once a case has been setup correctly so it can be run without errors, you may want 
to modify the postprocessing to of the simulation output. By default, NekRS will
output a basic set of data according to frequency set in the ``writeInterval`` of
the :ref:`parameter_file` which can subsequently be viewed through a visualization
tool such as Paraview or Visit. However, additional data or derived values can
be extracted by setting up User Defined outputs using the ``UDF_ExecuteStep``
function of the ``.udf`` file.

The ``UDF_ExecuteStep`` function is called at the start of the simulation and 
once per time step. Therefore, to ensure good performance you must check the
time status of the execution for any potential functionality. E.G. you can 
check the current step should be used for checkpointing with the  
``nrs->isCheckpointStep`` method, or calculate values at a specific frequency 
by checking the ``tstep`` integer parameter with a modulus operation.

.. code-block::

  void UDF_ExecuteStep(double time, int tstep)
  {
    if (nrs->isCheckpointStep) {
      // code here 
    }

    if (tstep % 100 == 0) {
      // code here
    }
  }

.. _checkpointing_visualisation:

Checkpointing & Visualization
-----------------------------

Standard NekRS field data output files have the form ``<case>0.f<n>``, where ``<case>`` is the
case name and ``<n>`` is a five-digit number indicating the number of the output
file (each output file represents a single time step that is output according to
the settings for ``writeControl`` and ``writeInterval`` in the ``.par`` file).
These output files are in a custom binary format that requires a ``<case>.nek5000``
file to be viewable in Paraview (or similar tools). This should be automatically
generated by NekRS, but can also be manually created using the ``nrsvis`` script.

Compute Derived Quantity
------------------------


Additional control of the simulation to compute additional/derived quantities 
or output custom fields can be achieved by utilising the ``UDF_ExecuteStep`` 
function of the ``.udf`` file. Here we demonstrate how this can be used to 
compute a derived quantity and output custom fields.

Qcriterion in turbPipe example

Example???

Adding Custom Checkpoint Fields
-------------------------------

nrs->addUserCheckpointField("scalar01", std::vector<deviceMemory<dfloat>>{o_nuAVM});

Adding Custom Output File
-------------------------


.. _turbulence_stats:

Run time averaging
------------------
